import { createUrl, handleRequest, authorizationHeaders } from "../request.js";
import { providerUserAuth } from "../core.js";
import { scope, generateState, encodeBase64 } from "../utils.js";
import { generateRandomString } from "lucia/utils";
const PROVIDER_ID = "lichess";
export const lichess = (auth, config) => {
    const getAuthorizationUrl = async () => {
        const state = generateState();
        // PKCE code verifier length and alphabet defined in RFC 7636 section 4.1
        const codeVerifier = generateRandomString(96, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890-_.~");
        const url = createUrl("https://lichess.org/oauth", {
            response_type: "code",
            client_id: config.clientId,
            code_challenge_method: "S256",
            code_challenge: pkceBase64urlEncode(await pkceCodeChallenge(codeVerifier)),
            scope: scope([], config.scope),
            redirect_uri: config.redirectUri,
            state
        });
        return [url, state, codeVerifier];
    };
    const getLichessTokens = async (code, codeVerifier) => {
        // Not using createUrl since we need to POST
        const request = new Request("https://lichess.org/api/token", {
            method: "POST",
            headers: {
                "Content-Type": "application/x-www-form-urlencoded"
            },
            body: new URLSearchParams({
                client_id: config.clientId,
                grant_type: "authorization_code",
                redirect_uri: config.redirectUri,
                code_verifier: codeVerifier,
                code
            }).toString()
        });
        const tokens = await handleRequest(request);
        return {
            accessToken: tokens.access_token,
            accessTokenExpiresIn: tokens.expires_in
        };
    };
    const getLichessUser = async (accessToken) => {
        const request = new Request("https://lichess.org/api/account", {
            headers: authorizationHeaders("bearer", accessToken)
        });
        const lichessUser = await handleRequest(request);
        return lichessUser;
    };
    const validateCallback = async (code, code_verifier) => {
        const lichessTokens = await getLichessTokens(code, code_verifier);
        const lichessUser = await getLichessUser(lichessTokens.accessToken);
        const providerUserId = lichessUser.id;
        const lichessUserAuth = await providerUserAuth(auth, PROVIDER_ID, providerUserId);
        return {
            ...lichessUserAuth,
            lichessUser,
            lichessTokens
        };
    };
    return {
        getAuthorizationUrl,
        validateCallback
    };
};
// Base64url-encode as specified in RFC 7636 (OAuth PKCE).
const pkceBase64urlEncode = (arg) => {
    return encodeBase64(arg)
        .split("=")[0]
        .replace(/\+/g, "-")
        .replace(/\//g, "_");
};
// Generates code_challenge from code_verifier, as specified in RFC 7636.
const pkceCodeChallenge = async (verifier) => {
    const verifierBuffer = new TextEncoder().encode(verifier);
    const challengeBuffer = await crypto.subtle.digest("SHA-256", verifierBuffer);
    const challengeArray = Array.from(new Uint8Array(challengeBuffer));
    return String.fromCharCode(...challengeArray);
};
